# Project Overview

**Name:** AI Agents v2 - Build an AI Agent from Scratch
**Description:** A two-day course teaching how to build a general-purpose, terminal-based AI agent from first principles using TypeScript and the OpenAI SDK. No frameworks, no magic—just a custom tool-calling loop with conversation history.

## Tech Stack

| Layer | Technology | Notes |
|-------|------------|-------|
| Runtime | Node.js | ES2022 modules |
| Language | TypeScript | Strict mode |
| LLM | Vercel AI SDK | `ai` + `@ai-sdk/openai` packages |
| Terminal UI | Ink | React-based terminal components |
| Browser Automation | Playwright | For browser handoff tool |
| Linting/Formatting | Biome | Code style enforcement |

## Project Structure

```
src/
├── index.ts           # Development entry point (renders Ink app)
├── cli.ts             # CLI entry point with shebang (for global install)
├── types.ts           # Shared type definitions
├── agent/
│   ├── run.ts         # Agent runner with streamText loop
│   ├── executeTool.ts # Tool execution dispatcher
│   ├── system/        # System prompts
│   └── tools/         # Individual tool implementations
└── ui/
    ├── App.tsx        # Main Ink application
    ├── index.tsx      # UI exports
    └── components/    # Reusable UI components

dist/                  # Compiled JavaScript (generated by npm run build)
```

## Conventions

### Code Style
- ES modules only (`"type": "module"`)
- TypeScript strict mode
- Biome for linting and formatting
- Vercel AI SDK with manual agent loop (no auto-execution)

### File Naming
- camelCase for TypeScript files: `executeTool.ts`
- kebab-case for directories when needed

### TypeScript
- Target: ES2021
- Module: ES2022
- Strict type checking enabled

### Running the Agent

**Global Installation (recommended):**
```bash
# Build and install globally
npm run build
npm install -g .

# Run from any directory
agi
```

**Development Mode:**
- `npm run dev` - Run with watch mode (auto-restart on changes)
- `npm run start` - Run directly via tsx
- Interactive Ink-based terminal UI

## Architecture

### Agent Loop Pattern
The core is a manual streamText loop with tool execution:

```
1. User sends message via Ink input
2. Append to conversation history (CoreMessage[])
3. Call streamText with history + tools
4. Stream tokens to UI via fullStream iteration
5. If finishReason === 'tool-calls':
   a. Execute tools in parallel (Promise.all)
   b. Append tool results to history
   c. Go to step 3
6. If finishReason !== 'tool-calls':
   a. Display final response
   b. Wait for next user input
```

### Conversation History
- Array of AI SDK CoreMessage objects
- Roles: `system`, `user`, `assistant`, `tool`
- Tool results use structured output: `{ type: 'text', value: string }`

### Tool Design
- Tools defined using AI SDK `tool()` helper with Zod schemas
- `inputSchema` defines parameters (validated by AI SDK)
- Optional `execute` function for tool implementation
- Tool dispatcher switches over tool name to call implementations

## Course Schedule

### Day 1
- Intro, Demo, Hello World
- Eval Baseline
- Decision Engine
- Tools and Actions
- Tool-Calling Loop

### Day 2
- Context and Memory
- Retrieval and Web Search
- Tracing and Debugging
- Advanced Evals and Metrics
- Guardrails, HITL, and Composition

## Key Concepts

1. **Core Primitives**: Models, tools, state, memory, orchestration
2. **Custom Tool Loop**: Conversation history-based, no framework abstraction
3. **Tool Types**: Filesystem, web search, code execution, browser handoff
4. **Context Management**: Retrieval for large contexts without token overflow
5. **Evals**: Single-step and multi-step evaluation patterns
6. **Guardrails**: Human-in-the-loop for risky tools (shell, bulk edits)
7. **Composition**: Agents as tools, agent-to-agent orchestration

## Environment

- Node.js 18+
- OpenAI API key (`OPENAI_API_KEY`)
- Local terminal execution
