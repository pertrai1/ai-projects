import Anthropic from "@anthropic-ai/sdk";
import { MetricCalculatorResult } from "../../src/types/index.js";
import { DatabaseSchema } from "../../src/types/index.js";

// Simple in-memory cache for query correctness scores
const cache = new Map<string, MetricCalculatorResult>();

/**
 * Generate cache key for query pair
 */
function getCacheKey(generated: string, expected: string): string {
  return `${generated.trim()}|||${expected.trim()}`;
}

/**
 * Normalize SQL for string comparison (remove whitespace, lowercase)
 */
function normalizeSQL(sql: string): string {
  return sql
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}

/**
 * Calculate query correctness using LLM-as-judge
 * Uses Claude to evaluate semantic similarity between generated and expected SQL
 *
 * @param generatedSql - The SQL generated by the system
 * @param expectedSql - The expected SQL query
 * @param schema - Database schema for context
 * @returns Score: 1.0 (correct), 0.5 (partial), 0.0 (wrong)
 */
export async function calculateQueryCorrectness(
  generatedSql: string,
  expectedSql: string,
  schema?: DatabaseSchema
): Promise<MetricCalculatorResult> {
  try {
    // Check cache first
    const cacheKey = getCacheKey(generatedSql, expectedSql);
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey)!;
    }

    // Shortcut: If queries are identical after normalization, return 1.0
    if (normalizeSQL(generatedSql) === normalizeSQL(expectedSql)) {
      const result = {
        score: 1.0,
        reasoning: "Queries are identical",
      };
      cache.set(cacheKey, result);
      return result;
    }

    // Use Claude as judge
    const client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    const schemaContext = schema
      ? `\nDatabase schema:\n${JSON.stringify(
          schema.tables.map((t) => ({
            name: t.name,
            columns: t.columns.map((c) => c.name),
          })),
          null,
          2
        )}`
      : "";

    const judgePrompt = `You are an expert SQL judge. Compare two SQL queries and determine if they are semantically equivalent.

${schemaContext}

Expected SQL:
${expectedSql}

Generated SQL:
${generatedSql}

Evaluate the generated SQL and provide:
1. A score: 1.0 (semantically correct), 0.5 (partially correct), or 0.0 (incorrect)
2. Brief reasoning for your score

Consider:
- Do both queries produce the same results?
- Are there semantic differences (different tables, columns, filters)?
- Minor syntax differences (JOIN order, AS keyword) are acceptable
- Different boolean representations (true/1, false/0) are acceptable

Respond in this exact format:
SCORE: [0.0, 0.5, or 1.0]
REASONING: [your explanation]`;

    const response = await client.messages.create({
      model: "claude-3-5-haiku-20241022", // Use Haiku for cost efficiency
      max_tokens: 300,
      temperature: 0,
      messages: [
        {
          role: "user",
          content: judgePrompt,
        },
      ],
    });

    // Parse response
    const content =
      response.content[0].type === "text" ? response.content[0].text : "";

    const scoreMatch = content.match(/SCORE:\s*([0-9.]+)/);
    const reasoningMatch = content.match(/REASONING:\s*(.+)/s);

    if (!scoreMatch) {
      throw new Error("Failed to parse score from LLM response");
    }

    const score = parseFloat(scoreMatch[1]);
    const reasoning = reasoningMatch
      ? reasoningMatch[1].trim()
      : "No reasoning provided";

    // Validate score
    if (![0.0, 0.5, 1.0].includes(score)) {
      throw new Error(`Invalid score from LLM: ${score}`);
    }

    const result = {
      score,
      reasoning,
    };

    // Cache result
    cache.set(cacheKey, result);

    return result;
  } catch (error) {
    return {
      score: 0.0,
      error: `Failed to calculate query correctness: ${
        error instanceof Error ? error.message : String(error)
      }`,
    };
  }
}

/**
 * Clear the query correctness cache
 * Useful for testing or when starting a new evaluation run
 */
export function clearCache(): void {
  cache.clear();
}
