import { MetricCalculatorResult } from "../../src/types/index.js";

/**
 * Extract table names from SQL query
 * Handles FROM and JOIN clauses, table aliases, and case normalization
 */
function extractTableNames(sql: string): string[] {
  const tables = new Set<string>();

  // Normalize to lowercase for case-insensitive matching
  const normalizedSql = sql.toLowerCase();

  // Match FROM clause: FROM table_name or FROM table_name AS alias
  const fromMatches = normalizedSql.matchAll(
    /from\s+([a-z_][a-z0-9_]*)\s*(?:as\s+[a-z_][a-z0-9_]*)?/gi
  );
  for (const match of fromMatches) {
    if (match[1]) {
      tables.add(match[1].toLowerCase());
    }
  }

  // Match JOIN clauses: JOIN table_name or JOIN table_name AS alias
  const joinMatches = normalizedSql.matchAll(
    /(?:inner\s+|left\s+|right\s+|full\s+|cross\s+)?join\s+([a-z_][a-z0-9_]*)\s*(?:as\s+[a-z_][a-z0-9_]*)?/gi
  );
  for (const match of joinMatches) {
    if (match[1]) {
      tables.add(match[1].toLowerCase());
    }
  }

  return Array.from(tables);
}

/**
 * Calculate Jaccard similarity between two sets
 * Formula: |intersection| / |union|
 */
function jaccardSimilarity(set1: Set<string>, set2: Set<string>): number {
  if (set1.size === 0 && set2.size === 0) {
    return 1.0; // Both empty = perfect match
  }

  const intersection = new Set([...set1].filter((x) => set2.has(x)));
  const union = new Set([...set1, ...set2]);

  return intersection.size / union.size;
}

/**
 * Calculate table accuracy metric
 * Compares tables used in generated SQL with expected tables
 *
 * @param generatedSql - The SQL query generated by the system
 * @param expectedTables - Array of expected table names
 * @returns Score between 0.0 and 1.0 (Jaccard similarity)
 */
export async function calculateTableAccuracy(
  generatedSql: string,
  expectedTables: string[]
): Promise<MetricCalculatorResult> {
  try {
    // Extract tables from generated SQL
    const extractedTables = extractTableNames(generatedSql);

    // Normalize expected tables to lowercase
    const normalizedExpected = expectedTables.map((t) => t.toLowerCase());

    // Convert to sets for Jaccard similarity
    const extractedSet = new Set(extractedTables);
    const expectedSet = new Set(normalizedExpected);

    // Calculate Jaccard similarity
    const score = jaccardSimilarity(extractedSet, expectedSet);

    // Generate reasoning
    let reasoning = "";
    if (score === 1.0) {
      reasoning = "Perfect table match";
    } else if (score > 0.5) {
      const missing = [...expectedSet].filter((t) => !extractedSet.has(t));
      const extra = [...extractedSet].filter((t) => !expectedSet.has(t));
      reasoning = `Partial match (${score.toFixed(2)}). `;
      if (missing.length > 0) {
        reasoning += `Missing: ${missing.join(", ")}. `;
      }
      if (extra.length > 0) {
        reasoning += `Extra: ${extra.join(", ")}.`;
      }
    } else {
      reasoning = `Poor table match (${score.toFixed(2)})`;
    }

    return {
      score,
      reasoning: reasoning.trim(),
    };
  } catch (error) {
    return {
      score: 0.0,
      error: `Failed to calculate table accuracy: ${
        error instanceof Error ? error.message : String(error)
      }`,
    };
  }
}
